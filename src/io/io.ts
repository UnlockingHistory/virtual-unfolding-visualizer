import { Vector3 } from 'three';
import * as utils from '../shared/utils';
import * as constants from '../shared/constants';
import * as types from '../shared/types';

// Tom header
// [22*2 = 44 bytes] uint16_t xsize,ysize,zsize,lmarg,rmarg,tmarg,bmarg,tzmarg,bzmarg,num_samples,num_proj,num_blocks,num_slices,bin,gain,speed,pepper,issue,num_frames,spare_int[13]__attribute__((packed));
// [13*4 = 52 bytes] float32 scale,offset,voltage,current,thickness,pixel_size,distance,exposure,mag_factor,filterb,correction_factor,spare_float[2]__attribute__((packed));
// [8*4 = 32 bytes] uint32_t z_shift,z,theta,spare_uint32[5]__attribute__((packed));
// [384*1 = 384 bytes] char time[26],duration[12],owner[21],user[5],specimen[32],scan[32],comment[64],spare_char[192];

export async function readTom(file: File) {

	// Read data.
	const type = await getTomDataType(file);
	const typedArray = (await readData(file, type, constants.TOM_HEADER_NUM_BYTES)) as types.TypedArray;

	// Check that data is correct size.
	const [dimensions, numElements] = await Promise.all([getTomDimensions(file), getTomNumElements(file)]);
	if (typedArray.length !== dimensions.x * dimensions.y * dimensions.z * numElements) {
		throw new Error(`Error reading ${file.name}. Expected tom dimensions ${utils.stringifyVector3(dimensions)} not compatible with data of length ${typedArray.length}.`);
	}

	return typedArray;
};

export async function getTomDimensions(file: File) {

	// Get data.
	const data = await readData(file, 'uint16', constants.TOM_DIMENSIONS_START_POSITION, constants.TOM_DIMENSIONS_NUM_BYTES);

	// Create Vector3 from dimensions.
	const dim = new Vector3(data[0], data[1], data[2]);
	if (!utils.isPositiveInteger(dim.x) || !utils.isPositiveInteger(dim.y)
        || !utils.isPositiveInteger(dim.z)) {
		throw new Error(`Error reading ${file.name}. Tom dimensions must be positive integers: ${utils.stringifyVector3(dim)}`);
	}
	return dim;
};

export async function getTomNumElements(file: File) {

	// Read marker from header, should read 'NumEl'.
	const marker = await readString(file, constants.TOM_NUM_ELEMENTS_START_POSITION, constants.TOM_NUM_ELEMENTS_MARKER.length);
	if (marker !== constants.TOM_NUM_ELEMENTS_MARKER) {
		// This is a tom file not generated by us, assume 1 element per voxel.
		return 1;
	}

	// Read next byte to get num elements.
	const data = await readData(file, 'uint8', constants.TOM_NUM_ELEMENTS_START_POSITION + constants.TOM_NUM_ELEMENTS_MARKER.length,
		constants.TOM_NUM_ELEMENTS_NUM_BYTES - constants.TOM_NUM_ELEMENTS_MARKER.length);

	// Parse as Uint8.
	const numElements = data[0];
	if (!utils.isPositiveInteger(numElements)) {
		throw new Error(`Error reading ${file.name}. Invalid num elements: ${numElements}.`);
	}
	return numElements;
};

export async function getTomUseNull(file: File) {

	// Read marker from header, should read 'Null'.
	const marker = await readString(file, constants.TOM_USE_NULL_START_POSITION, constants.TOM_USE_NULL_MARKER.length);
	if (marker !== constants.TOM_USE_NULL_MARKER) {
		// This is a tom file not generated by us, assume null is not encoded.
		return false;
	}

	// Read next byte to get use null bit.
	const data = await readData(file, 'uint8', constants.TOM_USE_NULL_START_POSITION + constants.TOM_USE_NULL_MARKER.length,
		constants.TOM_USE_NULL_NUM_BYTES - constants.TOM_USE_NULL_MARKER.length);

	// Parse as bool.
	const useNull = data[0];
	if (!utils.isNonNegativeInteger(useNull) || useNull > 1) {
		throw new Error(`Error reading ${file.name}. Invalid use null flag: ${useNull}.`);
	}
	return useNull > 0;
};

export async function getTomDataType(file: File) {
	// Read string from file.
	const type = (await readString(file, constants.TOM_DATA_TYPE_START_POSITION, constants.TOM_DATA_TYPE_NUM_BYTES)).replace(/\0/g, '');

	// Parse data type.
	switch(type) {
		case 'float32':
			return 'float32';
		case 'uint32':
			return 'uint32';
		case 'int32':
			return 'int32';
		case 'uint8':
		default:
			// Orig tom data from ct scans do not have datatype info in them.
			// We assume these are uint8.
			return 'uint8';
	}
}

export async function readBin(file: File) {
	// Read data.
	const type = await getBinDataType(file);
	const typedArray = await readData(file, type, constants.BIN_HEADER_NUM_BYTES);

	// Check that data is correct size.
	const [length, numElements] = await Promise.all([getBinLength(file), getBinNumElements(file)]);
	if (typedArray.length !== length * numElements) {
		throw new Error(`Error reading ${file.name}. Expected bin length ${length}, numElements ${numElements} not compatible with data of length ${typedArray.length}.`);
	}
	return typedArray;
};

export async function getBinLength(file: File) {

	// Read data as uint32.
	const data = await readData(file, 'uint32', constants.BIN_DIMENSIONS_START_POSITION, constants.BIN_DIMENSIONS_NUM_BYTES);

	// Create uint32 from dimensions.
	return data[0];
};

export async function getBinNumElements(file: File) {

	// Read data as uint8.
	const data = await readData(file, 'uint8', constants.BIN_NUM_ELEMENTS_START_POSITION, constants.BIN_NUM_ELEMENTS_NUM_BYTES);

	// Parse as uint8.
	const numElements = data[0];
	if (!utils.isPositiveInteger(numElements)) {
		throw new Error(`Error reading ${file.name}. Invalid num elements: ${numElements}.`);
	}
	return numElements;
};

export async function getBinUseNull(file: File) {
	const fullPath = `${file.name}.bin`;

	// Read data as uint8.
	const data = await readData(file, 'uint8', constants.BIN_USE_NULL_START_POSITION, constants.BIN_USE_NULL_NUM_BYTES);

	// Parse as bool.
	const useNull = data[0];
	if (!utils.isNonNegativeInteger(useNull) || useNull > 1) {
		throw new Error(`Error reading ${fullPath}. Invalid use null flag: ${useNull}.`);
	}
	return useNull > 0;
};

export async function getBinDataType(file: File) {

	// Read string from file.
	const type = (await readString(file, constants.BIN_DATA_TYPE_START_POSITION, constants.BIN_DATA_TYPE_NUM_BYTES)).replace(/\0/g, '');

	// Parse data type.
	switch(type) {
		case 'float32':
			return 'float32';
		case 'uint8':
			return 'uint8';
		case 'uint32':
			return 'uint32';
		case 'int32':
			return 'int32';
		default:
			throw new Error(`Error reading ${file.name}. Unknown data type: ${type}`);
	}
}

async function readData(file: File, type: types.TomType | 'uint16', start: number, length?: number) {

	// Load up buffer with full size of file (minus header).
    const buffer = await readFileToBuffer(file, start, length);

	switch (type) {
		case 'uint8':
			return new Uint8Array(buffer);
		case 'uint16':
			return new Uint16Array(buffer);
		case 'uint32':
			return new Uint32Array(buffer);
		case 'int32':
			return new Int32Array(buffer);
		case 'float32':
			return new Float32Array(buffer);
		default:
			throw new Error(`Error reading ${file.name}. Unsupported type: ${type}.`);
	}
}

async function readString(file: File, startPosition: number, length?: number) {
	const reader = new FileReader();
  
	return new Promise<string>((resolve, reject) => {
		reader.onerror = () => {
			reader.abort();
			reject(new DOMException(`Problem parsing file: ${file.name}`));
		};

		reader.onload = () => {
			resolve(reader.result as string);
		};
		const blob = file.slice(startPosition, length !== undefined ? startPosition + length : undefined);
		reader.readAsText(blob);
	});
};

async function readFileToBuffer(file: File, startPosition: number, length?: number) {
	const reader = new FileReader();
  
	return new Promise<ArrayBuffer>((resolve, reject) => {
		reader.onerror = () => {
			reader.abort();
			reject(new DOMException(`Problem parsing file: ${file.name}`));
		};

		reader.onload = () => {
			resolve(reader.result as ArrayBuffer);
		};
		const blob = file.slice(startPosition, length !== undefined ? startPosition + length : undefined);
		reader.readAsArrayBuffer(blob);
	});
};

// export function writeTom(path: string, filename: string, typedArray: types.TypedArray, dimensions: Vector3, numElements = 1, useNull = false) {
// 	const fullPath = `${path}${filename}.tom`;

// 	// Check typedArray.
// 	const { length } = typedArray;
// 	if (length === 0) {
// 		throw new Error(`Error saving ${fullPath}. Attempting to save array of length 0.`);
// 	}
// 	if (length !== dimensions.x * dimensions.y * dimensions.z * numElements) {
// 		throw new Error(`Error saving ${fullPath}. Dimensions ${utils.stringifyVector3(dimensions)}, num elements per voxel: ${numElements} not compatible with data of length ${length}.`);
// 	}
	
// 	// Get data type from TypedArray.
// 	const type = utils.typeOfTypedArray(typedArray);
// 	// Get data type length.
// 	const dataLength = utils.dataSizeForType(type);
	
// 	// Create buffer.
// 	const buffer = Buffer.alloc(constants.TOM_HEADER_NUM_BYTES + typedArray.length * dataLength);

// 	// Write header.
// 	writeTomHeaderToBuffer(fullPath, buffer, type, dimensions, numElements, useNull);

// 	// Fill remainder of buffer with data.
// 	writeDataToBuffer(fullPath, typedArray, buffer, constants.TOM_HEADER_NUM_BYTES);
	
// 	// Write file.
// 	let fd = fs.openSync(fullPath, 'w');
// 	fs.writeSync(fd, buffer);
	
// 	// Close file.
// 	fs.closeSync(fd);
// }

// export function writeTomHeaderToBuffer(fullPath: string, buffer: Buffer, type: types.TomType, dimensions: Vector3, numElements = 1, useNull = false) {
// 	// Check that numElements is a valid number.
// 	if (numElements > constants.MAX_NUM_ELEMENTS) {
// 		throw new Error(`Error saving ${fullPath}. Invalid num elements: ${numElements}.`);
// 	}

// 	// Write dimensions of tom data to header.
// 	writeDataToBuffer(fullPath, new Uint16Array(dimensions.toArray()), buffer, constants.TOM_DIMENSIONS_START_POSITION);

// 	// Write data type to header.
// 	writeStringToBuffer(fullPath, type, buffer, constants.TOM_DATA_TYPE_START_POSITION, constants.TOM_DATA_TYPE_NUM_BYTES);

// 	// Write num elements to header.
// 	writeStringToBuffer(fullPath, constants.TOM_NUM_ELEMENTS_MARKER, buffer, constants.TOM_NUM_ELEMENTS_START_POSITION, constants.TOM_NUM_ELEMENTS_MARKER.length);
// 	writeDataToBuffer(fullPath, new Uint8Array([numElements]), buffer, constants.TOM_NUM_ELEMENTS_START_POSITION + constants.TOM_NUM_ELEMENTS_MARKER.length);

// 	// Write useNull to header.
// 	writeStringToBuffer(fullPath, constants.TOM_USE_NULL_MARKER, buffer, constants.TOM_USE_NULL_START_POSITION, constants.TOM_USE_NULL_MARKER.length);
// 	writeDataToBuffer(fullPath, new Uint8Array([useNull ? 1 : 0]), buffer, constants.TOM_USE_NULL_START_POSITION + constants.TOM_USE_NULL_MARKER.length);
// }

// export function writeBin(path: string, filename: string, typedArray: types.TypedArray, numElements = 1, useNull = false) {
// 	const fullPath = `${path}${filename}.bin`;

// 	// Check typedArray.
// 	const { length } = typedArray;
// 	if (length === 0) {
// 		throw new Error(`Error saving ${fullPath}. Attempting to save array of length 0.`);
// 	}
// 	if (length % numElements !== 0) {
// 		throw new Error(`Error saving ${fullPath}. Num elements per entry: ${numElements} not compatible with data of length ${length}.`);
// 	}
// 	if (numElements > constants.MAX_NUM_ELEMENTS) {
// 		throw new Error(`Error saving ${fullPath}. Invalid num elements: ${numElements}.`);
// 	}

// 	// Get data type from TypedArray.
// 	const type = utils.typeOfTypedArray(typedArray);
// 	const dataLength = utils.dataSizeForType(type);

// 	// Create buffer.
// 	const buffer = Buffer.alloc(constants.BIN_HEADER_NUM_BYTES + typedArray.length * dataLength);

// 	// Write length to header.
// 	buffer.writeUInt32LE(length / numElements, constants.BIN_DIMENSIONS_START_POSITION);

// 	// Write data type to header.
// 	writeStringToBuffer(fullPath, type, buffer, constants.BIN_DATA_TYPE_START_POSITION, constants.BIN_DATA_TYPE_NUM_BYTES);

// 	// Write num elements to header.
// 	writeDataToBuffer(fullPath, new Uint8Array([numElements]), buffer, constants.BIN_NUM_ELEMENTS_START_POSITION);

// 	// Write useNull to header.
// 	writeDataToBuffer(fullPath, new Uint8Array([useNull ? 1 : 0]), buffer, constants.BIN_USE_NULL_START_POSITION);
	
// 	// Fill remainder of buffer with data.
// 	writeDataToBuffer(fullPath, typedArray, buffer, constants.BIN_HEADER_NUM_BYTES);

// 	// Write file.
// 	let fd = fs.openSync(fullPath, 'w');
// 	fs.writeSync(fd, buffer);

// 	// Close file.
// 	fs.closeSync(fd);
// }

// function writeStringToBuffer(fullPath: string, type: types.TomType | typeof constants.TOM_NUM_ELEMENTS_MARKER | typeof constants.TOM_USE_NULL_MARKER,
// 	buffer: Buffer, startPosition: number, numBytes: number) {

// 	const stringBuffer = Buffer.from(type, 'utf-8');
// 	if (stringBuffer.length > numBytes) {
// 		throw new Error(`Error saving ${fullPath}. Not enough bytes (${numBytes}) to store string ${type}`);
// 	}
// 	for (let i = 0; i < stringBuffer.length; i++) {
// 		buffer[startPosition + i] = stringBuffer[i];
// 	}
// }

// function writeDataToBuffer(fullPath: string, typedArray: types.TypedArray | Uint16Array, buffer: Buffer, startPosition: number) {
// 	// Write data to buffer.
// 	const { length } = typedArray;
// 	const type = utils.typeOfTypedArray(typedArray);
// 	switch (type) {
// 		case 'uint8':
// 			for (let i = 0; i < length; i++) {
// 				buffer[i + startPosition] = typedArray[i];
// 			}
// 			break;
// 		case 'uint32':
// 			for (let i = 0; i < length; i++) {
// 				buffer.writeUInt32LE(typedArray[i], 4 * i + startPosition);
// 			}
// 			break;
// 		case 'int32':
// 			for (let i = 0; i < length; i++) {
// 				buffer.writeInt32LE(typedArray[i], 4 * i + startPosition);
// 			}
// 			break;
// 		case 'float32':
// 			for (let i = 0; i < length; i++) {
// 				buffer.writeFloatLE(typedArray[i], 4 * i + startPosition);
// 			}
// 			break;
// 		case 'uint16':
// 			for (let i = 0; i < length; i++) {
// 				buffer.writeUInt16LE(typedArray[i], 2 * i + startPosition);
// 			}
// 			break;
// 		default:
// 			throw new Error(`Error saving ${fullPath}.  Unknown typed array constructor ${typedArray.constructor}.`);
// 	}
// }